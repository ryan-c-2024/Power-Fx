// <autogenerated>
// Use autogenerated to suppress stylecop warnings 

using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using DocumentFormat.OpenXml.InkML;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Spreadsheet;
using DocumentFormat.OpenXml.Wordprocessing;
using Microsoft.PowerFx;
using Microsoft.PowerFx.Core;
using Microsoft.PowerFx.Syntax;
using Microsoft.PowerFx.Types;
using Microsoft.PowerFx.Preview;
using Microsoft.PowerFx.Interpreter;
using Newtonsoft.Json;

namespace Excel2AppEngine
{
    
    [JsonObject(ItemNullValueHandling = NullValueHandling.Ignore)]
    public class ParsedExcelData
    {
        public List<ParsedCell> Cells;
        public List<ParsedDefinedNames> DefinedNames;
        public List<ParsedTable> Tables;
    }

    public class ParsedTable
    {
        public string Name;
        public string Range;
        public List<ParsedTableColumn> Columns;
    }

    [JsonObject(ItemNullValueHandling = NullValueHandling.Ignore)]
    public class ParsedTableColumn
    {
        public string Name;
        public string Formula;
    }

    [JsonObject(ItemNullValueHandling = NullValueHandling.Ignore)]
    public class ParsedDefinedNames
    {
        public string Name;
        public string Value;
    }

    [JsonObject(ItemNullValueHandling = NullValueHandling.Ignore)]
    public sealed class ParsedCell
    {
        public string SheetName;
        public string CellId;
        public string Formula;
        public string Value;
    }

    static class ExcelParser
    {
        public static ParsedExcelData parseSpreadsheet(String excelFilePath, bool outputFile = true)
        {
            TestCellId();
            TestSharedFormulaResolve();
            bool includeCellValues = true;

            string fileName = new FileInfo(excelFilePath).Name;

            using (SpreadsheetDocument spreadsheetDocument = SpreadsheetDocument.Open(excelFilePath, false))
            {
                var sheets = new Dictionary<string, Sheet>(spreadsheetDocument.WorkbookPart.Workbook.Sheets.Elements<Sheet>().Select(s => new KeyValuePair<string, Sheet>(s.Id.Value, s)));

                var jsonRows = new List<ParsedCell>();
                List<ParsedTable> jsonTables = new List<ParsedTable>();

                foreach (var workSheetPartInfo in spreadsheetDocument.WorkbookPart.Parts.Where(p => p.OpenXmlPart is WorksheetPart))
                {
                    Sheet sheet = sheets[workSheetPartInfo.RelationshipId];
                    Worksheet workSheet = ((WorksheetPart)workSheetPartInfo.OpenXmlPart).Worksheet;

                    Console.WriteLine(sheet.Name);

                    SheetData sheetData = workSheet.Elements<SheetData>().First();
                    SharedStringItem[] sharedStringTable = spreadsheetDocument.WorkbookPart.SharedStringTablePart?.SharedStringTable.Elements<SharedStringItem>().ToArray();
                    var sharedFormulas = new Dictionary<uint, SharedFormula>();


                    foreach (Row row in sheetData.Elements<Row>())
                    {
                        foreach (Cell cell in row.Elements<Cell>())
                        {
                            ParsedCell parsedCell = ParseCell(sheet.Name?.Value, cell, sharedStringTable, sharedFormulas, includeCellValues);

                            //Console.WriteLine("    " + JsonConvert.SerializeObject(parsedCell));
                            jsonRows.Add(parsedCell);
                        }
                    }

                    foreach (TableDefinitionPart tablePart in ((WorksheetPart)workSheetPartInfo.OpenXmlPart).TableDefinitionParts)
                    {
                        DocumentFormat.OpenXml.Spreadsheet.Table table = tablePart.Table; // formerly Table table = tablePart.Table  ... idk why that broke suddenly
                        ParsedTable parsedTable = new ParsedTable { Name = table.Name, Range = table.Reference };
                        List<ParsedTableColumn> parsedColumns = new List<ParsedTableColumn>();

                        foreach (TableColumn column in table.TableColumns)
                        {
                            if (column.CalculatedColumnFormula != null) // if the formula does not exist or is invalid don't include it (avoid exceptions)
                            {
                                parsedColumns.Add(new ParsedTableColumn { Name = column.Name, Formula = column.CalculatedColumnFormula.Text });
                            }
                            else
                            {
                                parsedColumns.Add(new ParsedTableColumn { Name = column.Name });
                            }
                        }

                        parsedTable.Columns = parsedColumns;
                        jsonTables.Add(parsedTable);
                    }

                }

                // Retrieve a reference to the defined names collection.
                DefinedNames definedNames = spreadsheetDocument.WorkbookPart.Workbook.DefinedNames;
                List<ParsedDefinedNames> jsonNames = new List<ParsedDefinedNames>();
                // If there are defined names, add them to the dictionary.
                if (definedNames != null)
                {
                    foreach (DefinedName dn in definedNames)
                        jsonNames.Add(new ParsedDefinedNames { Name = dn.Name.Value, Value = dn.Text });
                    //Console.WriteLine("{0} {1}", dn.Name.Value, dn.Text);
                }

                // does this result in copying of the whole object?
                ParsedExcelData output = new ParsedExcelData { Cells = jsonRows, DefinedNames = jsonNames, Tables = jsonTables };

                if (outputFile)
                {
                    string json = JsonConvert.SerializeObject(output, Formatting.Indented);
                    File.WriteAllText($"parsed-{fileName}.json", json);
                }

                return output;
            }
        }
        private static ParsedCell ParseCell(string sheetName, Cell spreadSheetCell, SharedStringItem[] sharedStringTable, Dictionary<uint, SharedFormula> sharedFormulas, bool includeCellValues)
        {
            if (spreadSheetCell.CellFormula == null && (!includeCellValues || spreadSheetCell.CellValue == null))
            {
                // If formula and value are null, this is an empty cell (happens when cells are merged) - ignore it.
                // If includeCellValues == false and there no formula - also ignore.
                return null;
            }

            var parsedCell = new ParsedCell()
            {
                SheetName = sheetName,
                CellId = spreadSheetCell.CellReference.Value,
                Formula = spreadSheetCell.CellFormula?.Text,
            };

            if (spreadSheetCell.CellFormula?.SharedIndex != null)
            {
                if (spreadSheetCell.CellFormula?.Reference != null)
                {
                    sharedFormulas[spreadSheetCell.CellFormula.SharedIndex.Value] = new SharedFormula(spreadSheetCell);
                }
                else
                {
                    SharedFormula sharedFormula = sharedFormulas[spreadSheetCell.CellFormula.SharedIndex.Value];
                    parsedCell.Formula = sharedFormula.ResolveFormula(new CellId(parsedCell.CellId));
                }
            }

            if (includeCellValues && spreadSheetCell.CellValue != null)
            {
                if (spreadSheetCell.DataType != null && spreadSheetCell.DataType == CellValues.SharedString)
                {
                    int sharedStringIndex;
                    parsedCell.Value = spreadSheetCell.CellValue.TryGetInt(out sharedStringIndex) ? sharedStringTable[sharedStringIndex].InnerText : null;
                }
                else
                {
                    parsedCell.Value = spreadSheetCell.CellValue.InnerText;
                }
            }

            return parsedCell;
        }

        private sealed class SharedFormula
        {
            private readonly CellId CellId;
            private readonly string Formula;
            private readonly CellId RangeStart;
            private readonly CellId RangeEnd;
            private readonly bool Horizontal;

            public SharedFormula(Cell cell)
            {
                Contract.Assert(cell != null && !string.IsNullOrWhiteSpace(cell.CellReference) && !string.IsNullOrWhiteSpace(cell.CellFormula?.Text),
                                "cell != null && !string.IsNullOrWhiteSpace(cell.CellReference) && !string.IsNullOrWhiteSpace(cell.CellFormula?.Text)");

                CellId = new CellId(cell.CellReference);
                Formula = cell.CellFormula.Text;

                string[] range = cell.CellFormula.Reference.Value.Split(':');
                Contract.Assert(1 <= range.Length && range.Length <= 2, "1 <= range.Length && range.Length <= 2");
                RangeStart = new CellId(range[0]);
                RangeEnd = new CellId(range.Length == 2 ? range[1] : range[0]);

                if (RangeStart.X < RangeEnd.X)
                {
                    Contract.Assert(RangeStart.Y == RangeEnd.Y, "RangeStart.Y == RangeEnd.Y");
                    Horizontal = true;
                }
                else if (RangeStart.Y < RangeEnd.Y)
                {
                    Contract.Assert(RangeStart.X == RangeEnd.X, "RangeStart.X == RangeEnd.X");
                    Horizontal = false;
                }
                else if (RangeStart.X == RangeEnd.X && RangeStart.Y == RangeEnd.Y)
                {
                    Contract.Assert(range.Length == 1, "range.Length == 1");
                    Horizontal = true;
                }
                else
                {
                    Contract.Assert(false, "Invalid shared formula range");
                }
            }

            public string ResolveFormula(CellId targetCellId)
            {
                int targetOffset;
                if (Horizontal)
                {
                    Contract.Assert(targetCellId.Y == RangeStart.Y && RangeStart.X <= targetCellId.X && targetCellId.X <= RangeEnd.X,
                                    "Horizontal: targetCellId.Y == RangeStart.Y && RangeStart.X <= targetCellId.X && targetCellId.X <= RangeEnd.X");
                    targetOffset = targetCellId.X - CellId.X;
                }
                else
                {
                    Contract.Assert(targetCellId.X == RangeStart.X && RangeStart.Y <= targetCellId.Y && targetCellId.Y <= RangeEnd.Y,
                                    "Vertical: targetCellId.X == RangeStart.X && RangeStart.Y <= targetCellId.Y && targetCellId.Y <= RangeEnd.Y");
                    targetOffset = targetCellId.Y - CellId.Y;
                }

                if (targetOffset == 0)
                {
                    return Formula;
                }
                else
                {
                    return ResolveFormula(Formula, targetOffset, Horizontal);
                }
            }

            public static string ResolveFormula(string formula, int targetOffset, bool horizontal)
            {
                Contract.Assert(targetOffset > 0, "targetOffset > 0");

                Match m = Regex.Match(formula, @"(?<=^|[^A-Z])(?<cellId>[A-Z]+[0-9]+)(?=$|[^0-9])");
                var sb = new StringBuilder();
                int prevSourceIndex = 0;
                while (m.Success)
                {
                    Contract.Assert(m.Groups["cellId"].Success, "m.Groups[\"cellId\"].Success");

                    sb.Append(formula.Substring(prevSourceIndex, m.Index - prevSourceIndex));

                    var templateCellId = new CellId(m.Value);

                    CellId targetCellId;
                    if (horizontal)
                    {
                        targetCellId = new CellId(templateCellId.X + targetOffset, templateCellId.Y);
                    }
                    else
                    {
                        targetCellId = new CellId(templateCellId.X, templateCellId.Y + targetOffset);
                    }

                    sb.Append(targetCellId);

                    prevSourceIndex = m.Index + m.Length;
                    m = m.NextMatch();
                }

                if (prevSourceIndex < formula.Length)
                {
                    sb.Append(formula.Substring(prevSourceIndex, formula.Length - prevSourceIndex));
                }

                return sb.ToString();
            }
        }

        private sealed class CellId
        {
            const int XBase = 'Z' - 'A' + 1; // 26

            public int X;
            public int Y;

            public CellId(string cellId)
            {
                Contract.Assert(!string.IsNullOrWhiteSpace(cellId), "!string.IsNullOrWhiteSpace(cellId)");

                int xEnd;
                for (xEnd = cellId.Length - 1; xEnd >= 0 && char.IsDigit(cellId[xEnd]); --xEnd) ;

                Contract.Assert(xEnd >= 0, "xEnd >= 0");

                X = X2Num(cellId.Substring(0, xEnd + 1));
                Y = int.Parse(cellId.Substring(xEnd + 1), CultureInfo.InvariantCulture);
            }

            public CellId(int x, int y)
            {
                Contract.Assert(x >= 0 && y >= 1, "x >= 0 && y => 1");
                X = x;
                Y = y;
            }

            /// <summary>
            /// BAB -> 1379
            /// </summary>
            public static int X2Num(string x)
            {
                Contract.Assert(!string.IsNullOrWhiteSpace(x), "!string.IsNullOrWhiteSpace(x)");

                int numX = 0;
                int adjustment = 0;
                for (int i = x.Length - 1; i >= 0; --i)
                {
                    Contract.Assert('A' <= x[i] && x[i] <= 'Z', "'A' <= x[i] && x[i] <= 'Z'");
                    numX += (x[i] - 'A' + adjustment) * (int)Math.Pow(XBase, x.Length - i - 1);

                    // This is because "A, B, ..., Y, Z, AA, AB" instead of "A, B, ..., Y, Z, BA, BB"
                    // "BAB" = 1379 = 1 + 26 + 1352
                    // B * Base^0 = 1 * 1 = 1
                    // A+1 * Base^1 = 0+1 * 26 = 26
                    // B+1 * Base^2 = 1+1 * 676 = 1352
                    // see WorksheetXdimMath.jpg
                    adjustment = 1;
                }

                Contract.Assert(numX >= 0, "numX >= 0");
                return numX;
            }

            /// <summary>
            /// 1379 -> BAB
            /// </summary>
            public static string X2Str(int x)
            {
                Contract.Assert(x >= 0, "x >= 0");

                var sb = new StringBuilder();

                while (x >= 0)
                {
                    int remainder = x % XBase;
                    sb.Insert(0, Char.ConvertFromUtf32('A' + remainder));
                    x = x / XBase - 1; // (- 1) is because "A, B, ..., Y, Z, AA, AB" instead of "A, B, ..., Y, Z, BA, BB"
                }

                return sb.ToString();
            }

            public override string ToString()
            {
                return $"{X2Str(X)}{Y}";
            }
        }

        private static void TestCellId()
        {
            for (int i = 0; i < 30000; ++i)
            {
                var xs = CellId.X2Str(i);
                var xn = CellId.X2Num(xs);
                var xs2 = CellId.X2Str(xn);

                // Console.WriteLine($"{i} {xs} {xn} {xs2}");

                if (xn != i)
                {
                    Contract.Assert(false);
                }
                if (xs != xs2)
                {
                    Contract.Assert(false);
                }
            }
        }

        private static void TestSharedFormulaResolve()
        {
            Contract.Assert(SharedFormula.ResolveFormula("1/B4-10", 2, horizontal: true) == "1/D4-10");
            Contract.Assert(SharedFormula.ResolveFormula("1/B4-10", 2, horizontal: false) == "1/B6-10");

            Contract.Assert(SharedFormula.ResolveFormula("1/B4-ZY1", 2, horizontal: true) == "1/D4-AAA1");
            Contract.Assert(SharedFormula.ResolveFormula("1/B4-ZY1", 2, horizontal: false) == "1/B6-ZY3");

            Contract.Assert(SharedFormula.ResolveFormula("AA1/B4-B10", 2, horizontal: true) == "AC1/D4-D10");
            Contract.Assert(SharedFormula.ResolveFormula("AA1/B4-B10", 2, horizontal: false) == "AA3/B6-B12");
        }
    }

    public class Converter
    {
       // public Converter() { } // do we have to do this to access constructor from outside this file????

        public static void Main(string[] args)
        {
            // would it be more efficient to run some of the processing AS WE ARE PARSING instead of after we're done?

            ParsedExcelData data = ExcelParser.parseSpreadsheet(@"CrawlWalkRun.xlsx"); // parse Excel spreadsheet and extract data
            Converter conv = new Converter();
            var engine = new Engine(new PowerFxConfig());

            foreach (ParsedCell c in data.Cells)
            {
                if (c == null) continue;

                if (c.Formula != null)
                {
                    // Node Kinds: call, unary, binary, table, record, etc
                    // Console.WriteLine("Cell {0} with value {1} and formula {2} and kind {3}", c.CellId, c.Value, c.Formula, res.Root.Kind);
                    ParseResult p = engine.Parse(c.Formula); // parse not just if formula, that way we can recognize string/numlit

                    if (p.Root.Kind == NodeKind.Call) // if the cell equals a function
                    {
                        Console.WriteLine(c.Formula);
                        conv.ProcessFunc((CallNode)p.Root);
                    }
                    else
                    {

                    }
                }
                else
                {
                    ParseResult p = engine.Parse(c.Value); // parse not just if formula, that way we can recognize string/numlit
                    if (p.Root.Kind == NodeKind.NumLit) // if the cell equals a numerical value
                    {
                        conv.CreateVariable(c.SheetName, c.CellId, (NumLitNode)p.Root);
                    }
                }
            }
        }

        private String convertFormula(String formula)
        {
            return formula;
        }

        private String ExpandRange(String range)
        {
            String ret = "";
            return ret;
        }
        private void ReplaceVar(String definedName)
        {

        }

        private void CreateVariable(String sheetName, String cellNum, NumLitNode node)
        {
            String genericName = GenerateGenericName(sheetName, cellNum, node);
            Console.WriteLine(genericName + " = " + node.ActualNumValue);
        }

        // Takes sheet name and cell number and creates a generic default PowerFX variable name for it
        // Eg. Cell B2 on Sheet1 -> Sheet1_B2
        // QUESTION: Should we keep the first letter of the variable uppercase at all times? lowercase? or base it on sheet name casing
        public String GenerateGenericName(String sheetName, String cellNum, NumLitNode node)
        {
            String output = sheetName + "_" + cellNum;
            return output;
        }

        // accepts all caps Excel function, converts to PowerFX style function name
        // EG: SUM -> Sum
        public String AdjustFuncName(String funcName)
        {
            // avoid exceptions so check the length beforehand
            // if name is empty (zero length) check first bc exceptions cause performance hit, confusion
            char[] retn = (funcName.ToLower()).ToCharArray();
            try
            {
                retn[0] = char.ToUpper(retn[0]);
            }
            catch (IndexOutOfRangeException e)
            {
                // function has no name (is invalid)
                Console.WriteLine("ERROR {0}: \"{1}\" passed as function name, returning empty string", e.Message, funcName);
                return "";
            }

            return new string(retn);
        }

        // Processes and converts a function to PowerFX equivalent, taking in a call node
        // DOES NOT CHECK IF OUTPUT IS A VALID POWERFX function
        // WIP - will support nested functions later
        public void ProcessFunc(CallNode node)
        {
            // add second project as unit test?
            // node = SUM(1, 2+2, 3)
            // ???
            // Sum(1, 2, 3)

            // SUM(C1:C5) -> Sum([C1, C2, C3, C4, C5])
            // SUM(A3:D9) -> Sum([A3, A4, A5, ... D9])

            // for now maybe unroll to Sum(A1, A2, A3, A4) instead of table


            // parser vs lexer
            // parser: toxenizes and notes identifiers and operators after scanning thru
            // then makes tree with identifiers operators and identifiers

            // ways of parsing range:

            // 1. hacky way
            // 
            // 2. right way
            // a1:a3 -> Range(A1, A3) (design new RangeNode object)

            // debug parsing of A1+A2 and figure out how parsing works behind the scenes

            ListNode funcArgs = node.Args;
            var funcName = node.Head.Name;

            String adjustedFuncName = AdjustFuncName(funcName.ToString()) + "("; // convert func name to PowerFX style
            IReadOnlyList<TexlNode> children = funcArgs.ChildNodes;

            TexlNode arg = children[0];
            for (int i = 0; i < children.Count; i++) // iterate over args and append them to output string
            {
                arg = children[i];
                if (i == (children.Count - 1)) // if only one argument or this is the last arg, close the parentheses
                {
                    adjustedFuncName += arg.ToString() + ")"; // injects arg.ToString()
                }
                else if (i >= 0 && i < (children.Count - 1)) // if not the last arg, add a comma and space for the next up arg
                {
                    adjustedFuncName += arg + ", ";
                }

            }
            Console.WriteLine(adjustedFuncName);

            //  for (TexlNode arg in funcArgs.ChildNodes)
            //    {
            //        adjustedFuncName += arg.ToString();
            //    }
            //    Console.WriteLine(adjustedFuncName);
            //adjustedFuncName.

            //Console.WriteLine(AdjustFuncName(funcName.ToString()));
            //node.

            /*
            // iterates and prints out all the arguments of the function call
            IReadOnlyList<TexlNode> children = funcArgs.ChildNodes;

            for (int i = 0; i < children.Count; i++) 
            {
                Console.Write("arg {0} is {1} w/ kind {2} ", i, children[i], children[i].Kind);
                if (children[i].Kind == NodeKind.Call) // node.AsFirstName
                {
                    CallNode subnode = (CallNode)children[i];
                    Console.WriteLine("subargs: {0}", subnode.Args.Count);
                }
                else if (children[i].Kind == NodeKind.FirstName)
                {
                    FirstNameNode blah = (FirstNameNode)children[i];
                    Console.WriteLine("FirstName Identifier name: {0}", blah.Ident.Name);
                }
                else if (children[i].Kind == NodeKind.UnaryOp)
                {
                    UnaryOpNode blah = (UnaryOpNode)children[i];
                    Console.WriteLine("UnaryOpNode op: {0} kind: {1} child: {2}", blah.Op, blah.Kind, blah.Child);
                }
                else if (children[i].Kind == NodeKind.StrLit)
                {
                    StrLitNode blah = (StrLitNode)children[i];
                }
            }
            */
        }
    }

    class ConsoleRepl
    {
        private static RecalcEngine engine;

        static void ResetEngine()
        {
            var config = new PowerFxConfig();

            engine = new RecalcEngine(config);
        }

        public static void run()
        {
            ResetEngine();

            var version = typeof(RecalcEngine).Assembly.GetName().Version.ToString();
            Console.WriteLine($"Microsoft Power Fx Console Formula REPL, Version {version}");
            Console.WriteLine($"Enter Excel formulas.  Use \"Help()\" for details.");

            // loop
            while (true)
            {
                // read
                Console.Write("\n> ");
                var expr = Console.ReadLine();

                try
                {
                    Match match;

                    // variable assignment: Set( <ident>, <expr> )
                    if ((match = Regex.Match(expr, @"^\s*Set\(\s*(?<ident>\w+)\s*,\s*(?<expr>.*)\)\s*$")).Success)
                    {
                        var r = engine.Eval(match.Groups["expr"].Value);
                        Console.WriteLine(match.Groups["ident"].Value + ": " + PrintResult(r));
                        engine.UpdateVariable(match.Groups["ident"].Value, r);
                    }

                    // formula definition: <ident> = <formula>
                    else if ((match = Regex.Match(expr, @"^\s*(?<ident>\w+)\s*=(?<formula>.*)$")).Success)
                        engine.SetFormula(match.Groups["ident"].Value, match.Groups["formula"].Value, OnUpdate);

                    // eval and print everything else, unless empty lines and single line comment (which do nothing)
                    else if (!Regex.IsMatch(expr, @"^\s*//") && Regex.IsMatch(expr, @"[^\s]"))
                    {
                        var result = engine.Eval(expr);

                        if (result is ErrorValue errorValue)
                            throw new Exception("Error: " + errorValue.Errors[0].Message);
                        else
                            Console.WriteLine(PrintResult(result));
                    }
                }
                catch (Exception e)
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine(e.Message);
                    Console.ResetColor();
                }
            }
        }

        static void OnUpdate(string name, FormulaValue newValue)
        {
            Console.Write($"{name}: ");
            if (newValue is ErrorValue errorValue)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("Error: " + errorValue.Errors[0].Message);
                Console.ResetColor();
            }
            else
                Console.WriteLine(PrintResult(newValue));
        }

        static string PrintResult(object value)
        {
            string resultString = "";

            if (value is BlankValue)
                resultString = "Blank()";
            else if (value is RecordValue record)
            {
                var separator = "";
                resultString = "{";
                foreach (var field in record.Fields)
                {
                    resultString += separator + $"{field.Name}:";
                    resultString += PrintResult(field.Value);
                    separator = ", ";
                }
                resultString += "}";
            }
            else if (value is TableValue table)
            {
                int valueSeen = 0, recordsSeen = 0;
                string separator = "";

                // check if the table can be represented in simpler [ ] notation,
                //   where each element is a record with a field named Value.
                foreach (var row in table.Rows)
                {
                    recordsSeen++;
                    if (row.Value is RecordValue scanRecord)
                    {
                        foreach (var field in scanRecord.Fields)
                            if (field.Name == "Value")
                            {
                                valueSeen++;
                                resultString += separator + PrintResult(field.Value);
                                separator = ", ";
                            }
                            else
                                valueSeen = 0;
                    }
                    else
                        valueSeen = 0;
                }

                if (valueSeen == recordsSeen)
                    return ("[" + resultString + "]");
                else
                {
                    // no, table is more complex that a single column of Value fields,
                    //   requires full treatment
                    resultString = "Table(";
                    separator = "";
                    foreach (var row in table.Rows)
                    {
                        resultString += separator + PrintResult(row.Value);
                        separator = ", ";
                    }
                    resultString += ")";
                }
            }
            else if (value is ErrorValue errorValue)
                resultString = "<Error: " + errorValue.Errors[0].Message + ">";
            else if (value is StringValue str)
                resultString = "\"" + str.ToObject().ToString().Replace("\"", "\"\"") + "\"";
            else if (value is FormulaValue fv)
                resultString = fv.ToObject().ToString();
            else
                throw new Exception("unexpected type in PrintResult");

            return (resultString);
        }

        private class ResetFunction : ReflectionFunction
        {
            public ResetFunction() : base("Reset", FormulaType.Boolean) { }

            public BooleanValue Execute()
            {
                ResetEngine();
                return FormulaValue.New(true);
            }
        }
    }

}



/*
              // Below code written by Ryan for testing purposes
              ParsedExcelData parsedFileData = JsonConvert.DeserializeObject<ParsedExcelData>(File.ReadAllText("parsed-BudgetSheet.xlsx.json"));
              foreach (ParsedCell c in parsedFileData.Cells)
              {
                  Console.WriteLine("" + c.Value + " " + c.CellId + " " + c.Formula);
              }
              for (int i = 0; i < 6; i++)
              {
                  Console.WriteLine(" ================================================ ");
              }
              foreach (ParsedDefinedNames n in parsedFileData.DefinedNames)
              {
                  Console.WriteLine("" + n.Name + " " + n.Value + " " + n);
              }
              for (int i = 0; i < 6; i++)
              {
                  Console.WriteLine(" ================================================ ");
              }
              foreach (ParsedTable t in parsedFileData.Tables)
              {
                  Console.WriteLine(t.Name);
                  foreach (ParsedTableColumn c in t.Columns)
                  {
                      Console.WriteLine(c.Name);
                      Console.WriteLine(c.Formula);
                  }
                  Console.WriteLine(" ===== ");
              }
              */
