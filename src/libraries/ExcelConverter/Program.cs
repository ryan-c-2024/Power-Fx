// <autogenerated>
// Use autogenerated to suppress stylecop warnings 

using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using DocumentFormat.OpenXml.InkML;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Spreadsheet;
using DocumentFormat.OpenXml.Wordprocessing;
using Microsoft.PowerFx;
using Microsoft.PowerFx.Core;
using Microsoft.PowerFx.Syntax;
using Microsoft.PowerFx.Types;
using Microsoft.PowerFx.Preview;
using Microsoft.PowerFx.Interpreter;
using Newtonsoft.Json;
using DocumentFormat.OpenXml.Office2010.PowerPoint;
using DocumentFormat.OpenXml.Drawing.Charts;

namespace ExcelConverter
{
    public class ExcelPfxResponse
    {
        public string CellId { get; set; }
        public string Formula { get; set; }
    }

    public class Converter
    {
        public static List<ExcelPfxResponse> outputList = new List<ExcelPfxResponse>();
        public static HashSet<String> processedSet = new HashSet<String>();

        // Maps generic variable names (String) to the defined name (String)
        // eg. Sheet1_C8 -> MyVariable
        public static Dictionary<String, String> definedNamesMap = new Dictionary<String, String>();

        // Maps range defined name (String) to the parsed range object (String)
        // eg. MyRange1 -> A3_RANGE_C9
        public static Dictionary<String, String> definedRangesMap = new Dictionary<String, String>();

        public static void Main(string[] args)
        {
            Init();
            // would it be more efficient to run some of the processing AS WE ARE PARSING instead of after we're done?
            // Also, sometimes ExcelConverter doesn't run past ParseSpreadsheet for some reason

            ExcelParser.ParsedExcelData data = ExcelParser.ParseSpreadsheet(@"SpotifyAnalysis.xlsx"); // parse Excel spreadsheet and extract data
            ConvertInternal(data);

            foreach(ExcelPfxResponse converted in outputList)
            {
                Console.WriteLine(converted.Formula);
            }
        }

        public static List<ExcelPfxResponse> ConvertFileFormulas(MemoryStream stream)
        {
            Init();
            ExcelParser.ParsedExcelData data = ExcelParser.ParseSpreadsheet(stream, false);
            ConvertInternal(data);
            
            return outputList;

        }

        public static List<ExcelPfxResponse> ConvertCellFormulas(ExcelParser.ParsedExcelData value)
        {
            Init();
            ExcelParser.ParsedExcelData data = new ExcelParser.ParsedExcelData
            {
                Cells = value.Cells ?? new List<ExcelParser.ParsedCell>(),
                DefinedNames = value.DefinedNames ?? new List<ExcelParser.ParsedDefinedNames>(),
                Tables = value.Tables ?? new List<ExcelParser.ParsedTable>()
            };

            ConvertInternal(data);

            return outputList;
        }

        /// <summary>
        /// Init structures
        /// Temporary workaround - need to reset these instances on each call to clear previous data, in the case of these being called from a Web App for example
        /// To address, we can update the converter to use class properties and pass an instance of the class to methods that need it.
        /// </summary>
        private static void Init()
        {
            outputList = new List<ExcelPfxResponse>();
            processedSet = new HashSet<String>();
            definedNamesMap = new Dictionary<String, String>();
            definedRangesMap = new Dictionary<String, String>();
        }

        private static void ConvertInternal(ExcelParser.ParsedExcelData data)
        {
            var engine = new Engine(new PowerFxConfig());

            foreach (ExcelParser.ParsedDefinedNames d in data.DefinedNames)
            {
                // Parse defined name to get the generic name (sheetname_cellnum) it corresponds to
                // If it's not a named cell, it's a named range...
                String parsedGenericName = Utils.ParseDefinedName(d);
                if (parsedGenericName != null)
                {
                    definedNamesMap.Add(parsedGenericName, d.Name); // Add to our map
                }
                else
                {
                    // Add range data to our map so we can convert the DefinedRange to a A3_RANGE_C9 style object
                    // In the current implementation a defined range ends up decomposed into its constituents when converted to PowerFX
                    // Eg. SUM(definedRange1) -> (eventually ...) -> Sum(Sheet1_C3, Sheet1_C4, ..., Sheet1_D9)
                    String parsedDefinedRange = Utils.ParseDefinedRange(d);
                    definedRangesMap.Add(d.Name, parsedDefinedRange);
                }
            }


            // Iterate through all parsed cells and convert to PFX if applicable            
            foreach (ExcelParser.ParsedCell c in data.Cells)
            {
                if (c == null || processedSet.Contains(c.CellId)) continue;

                ParseResult p;

                if (c.Formula != null)
                {
                    // If formula has a range, preprocess and reformat it
                    // Otherwise, the engine parser gets tripped up by the range colon
                    c.Formula = Utils.ReformatRange(c.Formula);
                    p = engine.Parse(c.Formula);
                }
                else
                {
                    p = engine.Parse(c.Value);
                }

                // only want to run PFX conversion if either a formula or a literal number node
                // Currently not converting StringLits because it often spams output with non-formula related cells
                if (c.Formula != null || p.Root.Kind == NodeKind.NumLit)
                {
                    // Convert to PFX then add it to our output list
                    String result = ParsedCellAnalyzer.Analyze(p.Root, c);

                    if (!processedSet.Contains(c.CellId))
                    {
                        outputList.Add(new ExcelPfxResponse { CellId = c.CellId, Formula = Utils.CreateVariable(c.SheetName, c.CellId, result.ToString()) });
                    }
                    processedSet.Add(c.CellId);
                }
            }
        }
    }
}
