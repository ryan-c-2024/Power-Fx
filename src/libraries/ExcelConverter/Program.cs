// <autogenerated>
// Use autogenerated to suppress stylecop warnings 

using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using DocumentFormat.OpenXml.InkML;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Spreadsheet;
using DocumentFormat.OpenXml.Wordprocessing;
using Microsoft.PowerFx;
using Microsoft.PowerFx.Core;
using Microsoft.PowerFx.Syntax;
using Microsoft.PowerFx.Types;
using Microsoft.PowerFx.Preview;
using Microsoft.PowerFx.Interpreter;
using Newtonsoft.Json;
using DocumentFormat.OpenXml.Office2010.PowerPoint;
using DocumentFormat.OpenXml.Drawing.Charts;

namespace Excel2AppEngine
{

    [JsonObject(ItemNullValueHandling = NullValueHandling.Ignore)]
    public class ParsedExcelData
    {
        public List<ParsedCell> Cells;
        public List<ParsedDefinedNames> DefinedNames;
        public List<ParsedTable> Tables;
    }

    public class ParsedTable
    {
        public string Name;
        public string Range;
        public List<ParsedTableColumn> Columns;
    }

    [JsonObject(ItemNullValueHandling = NullValueHandling.Ignore)]
    public class ParsedTableColumn
    {
        public string Name;
        public string Formula;
    }

    [JsonObject(ItemNullValueHandling = NullValueHandling.Ignore)]
    public class ParsedDefinedNames
    {
        public string Name;
        public string Value;
    }

    [JsonObject(ItemNullValueHandling = NullValueHandling.Ignore)]
    public sealed class ParsedCell
    {
        public string SheetName;
        public string CellId;
        public string Formula;
        public string Value;
    }

    static public class ExcelParser
    {
        public static ParsedExcelData ParseSpreadsheet(String excelFilePath, bool outputFile = true)
        {
            TestCellId();
            TestSharedFormulaResolve();
            bool includeCellValues = true;

            string fileName = new FileInfo(excelFilePath).Name;

            using (SpreadsheetDocument spreadsheetDocument = SpreadsheetDocument.Open(excelFilePath, false))
            {
                var sheets = new Dictionary<string, Sheet>(spreadsheetDocument.WorkbookPart.Workbook.Sheets.Elements<Sheet>().Select(s => new KeyValuePair<string, Sheet>(s.Id.Value, s)));

                var jsonRows = new List<ParsedCell>();
                List<ParsedTable> jsonTables = new List<ParsedTable>();

                foreach (var workSheetPartInfo in spreadsheetDocument.WorkbookPart.Parts.Where(p => p.OpenXmlPart is WorksheetPart))
                {
                    Sheet sheet = sheets[workSheetPartInfo.RelationshipId];
                    Worksheet workSheet = ((WorksheetPart)workSheetPartInfo.OpenXmlPart).Worksheet;

                    Console.WriteLine(sheet.Name);

                    SheetData sheetData = workSheet.Elements<SheetData>().First();
                    SharedStringItem[] sharedStringTable = spreadsheetDocument.WorkbookPart.SharedStringTablePart?.SharedStringTable.Elements<SharedStringItem>().ToArray();
                    var sharedFormulas = new Dictionary<uint, SharedFormula>();


                    foreach (Row row in sheetData.Elements<Row>())
                    {
                        foreach (Cell cell in row.Elements<Cell>())
                        {
                            ParsedCell parsedCell = ParseCell(sheet.Name?.Value, cell, sharedStringTable, sharedFormulas, includeCellValues);

                            //Console.WriteLine("    " + JsonConvert.SerializeObject(parsedCell));
                            jsonRows.Add(parsedCell);
                        }
                    }

                    foreach (TableDefinitionPart tablePart in ((WorksheetPart)workSheetPartInfo.OpenXmlPart).TableDefinitionParts)
                    {
                        DocumentFormat.OpenXml.Spreadsheet.Table table = tablePart.Table; // formerly Table table = tablePart.Table  ... idk why that broke suddenly
                        ParsedTable parsedTable = new ParsedTable { Name = table.Name, Range = table.Reference };
                        List<ParsedTableColumn> parsedColumns = new List<ParsedTableColumn>();

                        foreach (TableColumn column in table.TableColumns)
                        {
                            if (column.CalculatedColumnFormula != null) // if the formula does not exist or is invalid don't include it (avoid exceptions)
                            {
                                parsedColumns.Add(new ParsedTableColumn { Name = column.Name, Formula = column.CalculatedColumnFormula.Text });
                            }
                            else
                            {
                                parsedColumns.Add(new ParsedTableColumn { Name = column.Name });
                            }
                        }

                        parsedTable.Columns = parsedColumns;
                        jsonTables.Add(parsedTable);
                    }

                }

                // Retrieve a reference to the defined names collection.
                DefinedNames definedNames = spreadsheetDocument.WorkbookPart.Workbook.DefinedNames;
                List<ParsedDefinedNames> jsonNames = new List<ParsedDefinedNames>();
                // If there are defined names, add them to the dictionary.
                if (definedNames != null)
                {
                    foreach (DefinedName dn in definedNames)
                        jsonNames.Add(new ParsedDefinedNames { Name = dn.Name.Value, Value = dn.Text });
                    //Console.WriteLine("{0} {1}", dn.Name.Value, dn.Text);
                }

                // does this result in copying of the whole object?
                ParsedExcelData output = new ParsedExcelData { Cells = jsonRows, DefinedNames = jsonNames, Tables = jsonTables };

                if (outputFile)
                {
                    string json = JsonConvert.SerializeObject(output, Newtonsoft.Json.Formatting.Indented);
                    File.WriteAllText($"parsed-{fileName}.json", json);
                }

                return output;
            }
        }
        private static ParsedCell ParseCell(string sheetName, Cell spreadSheetCell, SharedStringItem[] sharedStringTable, Dictionary<uint, SharedFormula> sharedFormulas, bool includeCellValues)
        {
            if (spreadSheetCell.CellFormula == null && (!includeCellValues || spreadSheetCell.CellValue == null))
            {
                // If formula and value are null, this is an empty cell (happens when cells are merged) - ignore it.
                // If includeCellValues == false and there no formula - also ignore.
                return null;
            }

            var parsedCell = new ParsedCell()
            {
                SheetName = sheetName,
                CellId = spreadSheetCell.CellReference.Value,
                Formula = spreadSheetCell.CellFormula?.Text,
            };

            if (spreadSheetCell.CellFormula?.SharedIndex != null)
            {
                if (spreadSheetCell.CellFormula?.Reference != null)
                {
                    sharedFormulas[spreadSheetCell.CellFormula.SharedIndex.Value] = new SharedFormula(spreadSheetCell);
                }
                else
                {
                    SharedFormula sharedFormula = sharedFormulas[spreadSheetCell.CellFormula.SharedIndex.Value];
                    parsedCell.Formula = sharedFormula.ResolveFormula(new CellId(parsedCell.CellId));
                }
            }

            if (includeCellValues && spreadSheetCell.CellValue != null)
            {
                if (spreadSheetCell.DataType != null && spreadSheetCell.DataType == CellValues.SharedString)
                {
                    int sharedStringIndex;
                    parsedCell.Value = spreadSheetCell.CellValue.TryGetInt(out sharedStringIndex) ? sharedStringTable[sharedStringIndex].InnerText : null;
                }
                else
                {
                    parsedCell.Value = spreadSheetCell.CellValue.InnerText;
                }
            }

            return parsedCell;
        }

        private sealed class SharedFormula
        {
            private readonly CellId CellId;
            private readonly string Formula;
            private readonly CellId RangeStart;
            private readonly CellId RangeEnd;
            private readonly bool Horizontal;

            public SharedFormula(Cell cell)
            {
                Contract.Assert(cell != null && !string.IsNullOrWhiteSpace(cell.CellReference) && !string.IsNullOrWhiteSpace(cell.CellFormula?.Text),
                                "cell != null && !string.IsNullOrWhiteSpace(cell.CellReference) && !string.IsNullOrWhiteSpace(cell.CellFormula?.Text)");

                CellId = new CellId(cell.CellReference);
                Formula = cell.CellFormula.Text;

                string[] range = cell.CellFormula.Reference.Value.Split(':');
                Contract.Assert(1 <= range.Length && range.Length <= 2, "1 <= range.Length && range.Length <= 2");
                RangeStart = new CellId(range[0]);
                RangeEnd = new CellId(range.Length == 2 ? range[1] : range[0]);

                if (RangeStart.X < RangeEnd.X)
                {
                    Contract.Assert(RangeStart.Y == RangeEnd.Y, "RangeStart.Y == RangeEnd.Y");
                    Horizontal = true;
                }
                else if (RangeStart.Y < RangeEnd.Y)
                {
                    Contract.Assert(RangeStart.X == RangeEnd.X, "RangeStart.X == RangeEnd.X");
                    Horizontal = false;
                }
                else if (RangeStart.X == RangeEnd.X && RangeStart.Y == RangeEnd.Y)
                {
                    Contract.Assert(range.Length == 1, "range.Length == 1");
                    Horizontal = true;
                }
                else
                {
                    Contract.Assert(false, "Invalid shared formula range");
                }
            }

            public string ResolveFormula(CellId targetCellId)
            {
                int targetOffset;
                if (Horizontal)
                {
                    Contract.Assert(targetCellId.Y == RangeStart.Y && RangeStart.X <= targetCellId.X && targetCellId.X <= RangeEnd.X,
                                    "Horizontal: targetCellId.Y == RangeStart.Y && RangeStart.X <= targetCellId.X && targetCellId.X <= RangeEnd.X");
                    targetOffset = targetCellId.X - CellId.X;
                }
                else
                {
                    Contract.Assert(targetCellId.X == RangeStart.X && RangeStart.Y <= targetCellId.Y && targetCellId.Y <= RangeEnd.Y,
                                    "Vertical: targetCellId.X == RangeStart.X && RangeStart.Y <= targetCellId.Y && targetCellId.Y <= RangeEnd.Y");
                    targetOffset = targetCellId.Y - CellId.Y;
                }

                if (targetOffset == 0)
                {
                    return Formula;
                }
                else
                {
                    return ResolveFormula(Formula, targetOffset, Horizontal);
                }
            }

            public static string ResolveFormula(string formula, int targetOffset, bool horizontal)
            {
                Contract.Assert(targetOffset > 0, "targetOffset > 0");

                Match m = Regex.Match(formula, @"(?<=^|[^A-Z])(?<cellId>[A-Z]+[0-9]+)(?=$|[^0-9])");
                var sb = new StringBuilder();
                int prevSourceIndex = 0;
                while (m.Success)
                {
                    Contract.Assert(m.Groups["cellId"].Success, "m.Groups[\"cellId\"].Success");

                    sb.Append(formula.Substring(prevSourceIndex, m.Index - prevSourceIndex));

                    var templateCellId = new CellId(m.Value);

                    CellId targetCellId;
                    if (horizontal)
                    {
                        targetCellId = new CellId(templateCellId.X + targetOffset, templateCellId.Y);
                    }
                    else
                    {
                        targetCellId = new CellId(templateCellId.X, templateCellId.Y + targetOffset);
                    }

                    sb.Append(targetCellId);

                    prevSourceIndex = m.Index + m.Length;
                    m = m.NextMatch();
                }

                if (prevSourceIndex < formula.Length)
                {
                    sb.Append(formula.Substring(prevSourceIndex, formula.Length - prevSourceIndex));
                }

                return sb.ToString();
            }
        }

        private sealed class CellId
        {
            const int XBase = 'Z' - 'A' + 1; // 26

            public int X;
            public int Y;

            public CellId(string cellId)
            {
                Contract.Assert(!string.IsNullOrWhiteSpace(cellId), "!string.IsNullOrWhiteSpace(cellId)");

                int xEnd;
                for (xEnd = cellId.Length - 1; xEnd >= 0 && char.IsDigit(cellId[xEnd]); --xEnd) ;

                Contract.Assert(xEnd >= 0, "xEnd >= 0");

                X = X2Num(cellId.Substring(0, xEnd + 1));
                Y = int.Parse(cellId.Substring(xEnd + 1), CultureInfo.InvariantCulture);
            }

            public CellId(int x, int y)
            {
                Contract.Assert(x >= 0 && y >= 1, "x >= 0 && y => 1");
                X = x;
                Y = y;
            }

            /// <summary>
            /// BAB -> 1379
            /// </summary>
            public static int X2Num(string x)
            {
                Contract.Assert(!string.IsNullOrWhiteSpace(x), "!string.IsNullOrWhiteSpace(x)");

                int numX = 0;
                int adjustment = 0;
                for (int i = x.Length - 1; i >= 0; --i)
                {
                    Contract.Assert('A' <= x[i] && x[i] <= 'Z', "'A' <= x[i] && x[i] <= 'Z'");
                    numX += (x[i] - 'A' + adjustment) * (int)Math.Pow(XBase, x.Length - i - 1);

                    // This is because "A, B, ..., Y, Z, AA, AB" instead of "A, B, ..., Y, Z, BA, BB"
                    // "BAB" = 1379 = 1 + 26 + 1352
                    // B * Base^0 = 1 * 1 = 1
                    // A+1 * Base^1 = 0+1 * 26 = 26
                    // B+1 * Base^2 = 1+1 * 676 = 1352
                    // see WorksheetXdimMath.jpg
                    adjustment = 1;
                }

                Contract.Assert(numX >= 0, "numX >= 0");
                return numX;
            }

            /// <summary>
            /// 1379 -> BAB
            /// </summary>
            public static string X2Str(int x)
            {
                Contract.Assert(x >= 0, "x >= 0");

                var sb = new StringBuilder();

                while (x >= 0)
                {
                    int remainder = x % XBase;
                    sb.Insert(0, Char.ConvertFromUtf32('A' + remainder));
                    x = x / XBase - 1; // (- 1) is because "A, B, ..., Y, Z, AA, AB" instead of "A, B, ..., Y, Z, BA, BB"
                }

                return sb.ToString();
            }

            public override string ToString()
            {
                return $"{X2Str(X)}{Y}";
            }
        }

        private static void TestCellId()
        {
            for (int i = 0; i < 30000; ++i)
            {
                var xs = CellId.X2Str(i);
                var xn = CellId.X2Num(xs);
                var xs2 = CellId.X2Str(xn);

                // Console.WriteLine($"{i} {xs} {xn} {xs2}");

                if (xn != i)
                {
                    Contract.Assert(false);
                }
                if (xs != xs2)
                {
                    Contract.Assert(false);
                }
            }
        }

        private static void TestSharedFormulaResolve()
        {
            Contract.Assert(SharedFormula.ResolveFormula("1/B4-10", 2, horizontal: true) == "1/D4-10");
            Contract.Assert(SharedFormula.ResolveFormula("1/B4-10", 2, horizontal: false) == "1/B6-10");

            Contract.Assert(SharedFormula.ResolveFormula("1/B4-ZY1", 2, horizontal: true) == "1/D4-AAA1");
            Contract.Assert(SharedFormula.ResolveFormula("1/B4-ZY1", 2, horizontal: false) == "1/B6-ZY3");

            Contract.Assert(SharedFormula.ResolveFormula("AA1/B4-B10", 2, horizontal: true) == "AC1/D4-D10");
            Contract.Assert(SharedFormula.ResolveFormula("AA1/B4-B10", 2, horizontal: false) == "AA3/B6-B12");
        }
    }

    public class Converter
    {
        // public Converter() { } // do we have to do this to access constructor from outside this file????

        public static void Main(string[] args)
        {
            // would it be more efficient to run some of the processing AS WE ARE PARSING instead of after we're done?

            ParsedExcelData data = ExcelParser.ParseSpreadsheet(@"test.xlsx"); // parse Excel spreadsheet and extract data
            Converter conv = new Converter();
            var engine = new Engine(new PowerFxConfig());
            //ParsedCellAnalyzer pc = new ParsedCellAnalyzer();

            foreach (ParsedCell c in data.Cells)
            {
                if (c == null) continue;


                if (c.Formula != null)
                {
                    ParseResult p = engine.Parse(c.Formula); // parse not just if formula, that way we can recognize string/numlit
                    var result = ParsedCellAnalyzer.Analyze(p.Root, c);
                    Console.WriteLine(result);

                    /*
                      if (p.Root.Kind == NodeKind.Call) // if the cell equals a function
                    {
                        Console.WriteLine(conv.ProcessFunc((CallNode)p.Root, c));
                    }
                    else
                    {

                    }
                    */

                }
                else
                {
                    ParseResult p = engine.Parse(c.Value); // parse not just if formula, that way we can recognize string/numlit
                    var result = ParsedCellAnalyzer.Analyze(p.Root, c);
                    Console.WriteLine(result);

                    /*
                      if (p.Root.Kind == NodeKind.NumLit) // if the cell equals a numerical value
                    {
                        conv.CreateVariable(c.SheetName, c.CellId, (NumLitNode)p.Root);
                    }
                    */
                }
            }
        }


        /*
          private void HandleNode(TexlNode node, ParsedCell c)
        {
            switch (node.Kind)
            {
                case NodeKind.NumLit:
                    // how can we do this? we need ParsedCell object to get sheet name and cell ID
                    //GenerateGenericName()
                    break;
                case NodeKind.BinaryOp:
                    break;
                case NodeKind.Call:
                    ProcessFunc((CallNode)node, c);
                    break;
                default:
                    break;
            }
        }
        
         */


        private String ConvertFormula(String formula)
        {
            return formula;
        }

        private String ExpandRange(String range)
        {
            String ret = "";
            return ret;
        }
        private void ReplaceVar(String definedName)
        {

        }

        public static String CreateVariable(String sheetName, String cellNum, NumLitNode node)
        {
            String genericName = GenerateGenericName(sheetName, cellNum);
            return genericName + " = " + node.ActualNumValue;
        }

        // Takes sheet name and cell number and creates a generic default PowerFX variable name for it
        // Eg. Cell B2 on Sheet1 -> Sheet1_B2
        // QUESTION: Should we keep the first letter of the variable uppercase at all times? lowercase? or base it on sheet name casing
        public static String GenerateGenericName(String sheetName, String cellNum)
        {
            if (sheetName == null || sheetName == "" || cellNum == null || cellNum == "") return "";
            String output = sheetName + "_" + cellNum;
            return output;
        }

        // accepts all caps Excel function, converts to PowerFX style function name
        // EG: SUM -> Sum
        public static String AdjustFuncName(String funcName)
        {
            // avoid exceptions so check the length beforehand
            // if name is empty (zero length) check first bc exceptions cause performance hit, confusion
            char[] retn = (funcName.ToLower()).ToCharArray();
            try
            {
                retn[0] = char.ToUpper(retn[0]);
            }
            catch (IndexOutOfRangeException e)
            {
                // function has no name (is invalid)
                Console.WriteLine("ERROR {0}: \"{1}\" passed as function name, returning empty string", e.Message, funcName);
                return "";
            }

            return new string(retn);
        }

        // Processes and converts a function to PowerFX equivalent, taking in a call node
        // DOES NOT CHECK IF OUTPUT IS A VALID POWERFX function
        // WIP - will support nested functions later
        public static String ProcessFunc(CallNode node, ParsedCell c)
        {
            // add second project as unit test?
            // node = SUM(1, 2+2, 3)
            // ???
            // Sum(1, 2, 3)

            // SUM(C1:C5) -> Sum([C1, C2, C3, C4, C5])
            // SUM(A3:D9) -> Sum([A3, A4, A5, ... D9])

            // for now maybe unroll to Sum(A1, A2, A3, A4) instead of table


            // parser vs lexer
            // parser: toxenizes and notes identifiers and operators after scanning thru
            // then makes tree with identifiers operators and identifiers

            // ways of parsing range:

            // 1. hacky way
            // 
            // 2. right way
            // a1:a3 -> Range(A1, A3) (design new RangeNode object)

            // debug parsing of A1+A2 and figure out how parsing works behind the scenes



            ListNode funcArgs = node.Args;
            var funcName = node.Head.Name;

            String adjustedFuncName = AdjustFuncName(funcName.ToString()) + "("; // convert func name to PowerFX style
            IReadOnlyList<TexlNode> children = funcArgs.ChildNodes;

            TexlNode arg = children[0];
            for (int i = 0; i < children.Count; i++) // iterate over args and append them to output string
            {
                arg = children[i];
                String append = "";

                if (arg.Kind == NodeKind.Call) // if nested function call, we have to recurse
                {
                    append += ProcessFunc((CallNode)arg, c);
                }
                else if (arg.Kind == NodeKind.FirstName)
                {
                    // assume its a cell
                    // change cell name to generic variable and add 
                    // append = GenerateGenericName(c.SheetName, c.CellID);
                    // SUM(1, SUM(5,B13))
                    // -> B13 to string 
                    append = GenerateGenericName(c.SheetName, arg.ToString());
                }
                else
                {
                    append = arg.ToString();
                }

                if (i == (children.Count - 1)) // if only one argument or this is the last arg, close the parentheses
                {
                    adjustedFuncName += append + ")"; // injects arg.ToString()
                }
                else if (i >= 0 && i < (children.Count - 1)) // if not the last arg, add a comma and space for the next up arg
                {
                    adjustedFuncName += append + ", ";
                }

            }

            return adjustedFuncName;
        }
        public String ProcessFunc(String formula, Engine engine) // overload for ProcessFunc that wraps around and takes String input and engine
        {
            ParseResult p = engine.Parse(formula); // parse to get type and information using the passed in engine object
            if (p.Root.Kind != NodeKind.Call) return ""; // if not actually a function, return
            CallNode node = (CallNode)p.Root;
            return ProcessFunc(node, null); // fix me

        }

        public String ProcessFunc(String formula, ParseResult parse) // overload for ProcessFunc that wraps around and takes String input and parseresult
        {
            if (parse.Root.Kind != NodeKind.Call) return ""; // if not actually a function, return
            CallNode node = (CallNode)parse.Root;
            return ProcessFunc(node, null); // fix me
        }
    }
}
