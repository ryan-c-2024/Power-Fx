// <autogenerated>
// Use autogenerated to suppress stylecop warnings 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Microsoft.PowerFx;
using Microsoft.PowerFx.Core;
using Microsoft.PowerFx.Syntax;
using Microsoft.PowerFx.Types;

namespace ExcelConverter
{
    public class Utils
    {
        private String ConvertFormula(String formula)
        {
            return formula;
        }

        // Expands a range, outputting a string which is a comma-separated list of cells
        // Eg. ExpandRange('A', 3, 'B', 5) -> "A3, A4, A5, B3, B4, B5"
        public static String ExpandRange(char startRangeChar, int startRangeNum, char endRangeChar, int endRangeNum)
        {
            StringBuilder str = new StringBuilder("");
 
            // Iterate through the whole range (eg. A4 to C7) 
            // Expand the whole range with a nested for loop, appending to str
            for (int i = (int)startRangeChar; i <= (int)endRangeChar; i++)
            {
                for (int j = startRangeNum; j <= endRangeNum; j++)
                {
                    // If this is the last cell to expand, skip comma separation
                    if (i == (int)endRangeChar && j == endRangeNum)
                    {
                        str.AppendFormat("{0}{1}", (char)i, j);
                    }
                    else
                    {
                        str.AppendFormat("{0}{1}, ", (char)i, j);
                    }
                }
            }
            
            return str.ToString();
        }

        public static List<String> Interpolate(String leftStr, String rightStr, String opString)
        { 
            var strList = new List<String>();

            Regex rx = new Regex(@"([A-Z])(\d+)_RANGE_([A-Z])(\d+)(?=([^""']*[""'][^""']*[""'])*[^""']*$)");
            Match leftMatch = rx.Match(leftStr);
            Match rightMatch = rx.Match(rightStr);

            if (leftMatch.Success && rightMatch.Success)
            {
                // if there is a size mismatch between the two ranges we need to throw an exception
                char leftStartRangeChar = char.Parse(leftMatch.Groups[1].Value);
                int leftStartRangeNum = int.Parse(leftMatch.Groups[2].Value);
                char leftEndRangeChar = char.Parse(leftMatch.Groups[3].Value);
                int leftEndRangeNum = int.Parse(leftMatch.Groups[4].Value);

                char rightStartRangeChar = char.Parse(rightMatch.Groups[1].Value);
                int rightStartRangeNum = int.Parse(rightMatch.Groups[2].Value);
                char rightEndRangeChar = char.Parse(rightMatch.Groups[3].Value);
                int rightEndRangeNum = int.Parse(rightMatch.Groups[4].Value);


                // A1 to B2
                int leftRangeSize = (leftEndRangeChar - leftStartRangeChar + 1) * (leftEndRangeNum - leftStartRangeNum + 1);
                int rightRangeSize = (rightEndRangeChar - rightStartRangeChar + 1) * (rightEndRangeNum - rightStartRangeNum + 1);

                if (leftRangeSize != rightRangeSize)
                {
                    throw (new Exception("MISMATCH BETWEEN TWO RANGE SIZES IN BINARY OPERATOR"));
                }

                int k = (int)rightStartRangeChar;
                int l = (int)rightStartRangeNum;

                for (int i = (int)leftStartRangeChar; i <= (int)leftEndRangeChar; i++)
                {
                    for (int j = leftStartRangeNum; j <= leftEndRangeNum; j++)
                    {
                        strList.Add($"{(char)i}{j} {opString} {(char)k}{l}");
                        l++;
                    }

                    k++;
                }

            }
            else if (leftMatch.Success) // if left is a range, right isn't
            {
                // insert code here to convert right operand to generic variable if applicable

                char startRangeChar = char.Parse(leftMatch.Groups[1].Value);
                int startRangeNum = int.Parse(leftMatch.Groups[2].Value);
                char endRangeChar = char.Parse(leftMatch.Groups[3].Value);
                int endRangeNum = int.Parse(leftMatch.Groups[4].Value);

                // Iterate through the whole range (eg. A4 to C7) 
                // Expand the whole range with a nested for loop, appending to str
                for (int i = (int)startRangeChar; i <= (int)endRangeChar; i++)
                {
                    for (int j = startRangeNum; j <= endRangeNum; j++)
                    {
                        strList.Add($"{(char)i}{j} {opString} {rightStr}");                       
                    }
                }
            }
            else if (rightMatch.Success)
            {
                // insert code here to convert left operand to generic variable if applicable
                int startRangeChar = char.Parse(rightMatch.Groups[1].Value);
                int startRangeNum = int.Parse(rightMatch.Groups[2].Value);
                int endRangeChar = char.Parse(rightMatch.Groups[3].Value);
                int endRangeNum = int.Parse(rightMatch.Groups[4].Value);

                // Iterate through the whole range (eg. A4 to C7) 
                // Expand the whole range with a nested for loop, appending to str
                for (int i = (int)startRangeChar; i <= (int)endRangeChar; i++)
                {
                    for (int j = startRangeNum; j <= endRangeNum; j++)
                    {
                        strList.Add($"{leftStr} {opString} {(char)i}{j}");
                    }
                }
            }

            return strList;
        }

        private void ReplaceVar(String definedName)
        {

        }

        public static String CreateVariable(String sheetName, String cellNum, String variableValue)
        {
            String genericName = GenerateGenericName(sheetName, cellNum);
            return genericName + " = " + variableValue;
        }

        public static String CreateVariable(String sheetName, String cellNum, TexlNode node)
        {
            return CreateVariable(sheetName, cellNum, node.ToString());
        }

        // Takes sheet name and cell number and creates a generic default PowerFX variable name for it
        // Eg. Cell B2 on Sheet1 -> Sheet1_B2
        // QUESTION: Should we keep the first letter of the variable uppercase at all times? lowercase? or base it on sheet name casing
        public static String GenerateGenericName(String sheetName, String cellNum)
        {
            if (sheetName == null || sheetName == "" || cellNum == null || cellNum == "") return "";
            String output = sheetName + "_" + cellNum;
            return output;
        }

        // accepts all caps Excel function, converts to PowerFX style function name
        // EG: SUM -> Sum
        public static String AdjustFuncName(String funcName)
        {
            // Make the function name all lowercase and then capitalize the first letter
            char[] retn = (funcName.ToLower()).ToCharArray();
            try
            {
                retn[0] = char.ToUpper(retn[0]);
            }
            catch (IndexOutOfRangeException e)
            {
                // function has no name (is invalid) as indicated by retn[0] not existing
                Console.WriteLine("ERROR {0}: \"{1}\" passed as function name, returning empty string", e.Message, funcName);
                return "";
            }

            return new string(retn);
        }
     
        // Converts a BinaryOp enum value to the actual BinaryOp char
        public static String ConvertBinaryOp(BinaryOp op)
        {
            return binaryOpMap[op];
        }

        // Converts a UnaryOp enum value to the actual UnaryOp char
        public static String ConvertUnaryOp(UnaryOp op)
        {
            return unaryOpMap[op];
        }

        private static Dictionary<BinaryOp, String> binaryOpMap = new Dictionary<BinaryOp, String>()
            {
                {BinaryOp.Or, "||"},
                {BinaryOp.And, "&&"},
                {BinaryOp.Concat, "CONCAT"},
                {BinaryOp.Add, "+"},
                {BinaryOp.Mul, "*"},
                {BinaryOp.Div, "/"},
                {BinaryOp.Power, "^"},
                {BinaryOp.Equal, "="},
                {BinaryOp.NotEqual, "!="},
                {BinaryOp.Less, "<"},
                {BinaryOp.LessEqual, "<="},
                {BinaryOp.Greater, ">"},
                {BinaryOp.GreaterEqual, ">="},
                {BinaryOp.In, "IN"},
                {BinaryOp.Exactin, "EXACTIN"},
                {BinaryOp.Error, "ERROR"}
            };

        private static Dictionary<UnaryOp, String> unaryOpMap = new Dictionary<UnaryOp, String>()
            {
                {UnaryOp.Not, "!"},
                {UnaryOp.Minus, "-"},
                {UnaryOp.Percent, "%"}
            };
    }
}
