// <autogenerated>
// Use autogenerated to suppress stylecop warnings

using System;
using System.Collections.Generic;
using System.Net.Http.Headers;
using System.Text;
using System.Text.RegularExpressions;
using DocumentFormat.OpenXml.Wordprocessing;
using Microsoft.PowerFx;
using Microsoft.PowerFx.Core;
using Microsoft.PowerFx.Syntax;


namespace ExcelConverter
{
    /*
     * 1. ParsedCellAnalyzer extends TexlFunctionalVisitor (supports Accept returning values)
     * 2. ParsedCellAnalyzer.Analyze(string formula): use engine to parse nodes of formula
     * 3. Analyze(TexlNode node): "general recursion" - Accept new ParsedCellAnalyzer instance in child nodes/args
     * 4. ParsedCellAnalyzer: hold any object structures needed for that specific node, implement any specific functions
     *  e.g., Variable names <-> Identifier map, ranges as list of cells, calling pretty print, etc.
     *  
     *  Flow:
     *      - Parse Excel workbook
     *      - Use PFX Engine to parse cell objects
     *      - Pass parsed cell objects and parsed nodes to ParsedCellAnalyzer.Analyze()
     *      - Accept function called on node
     *      - Visitor pattern and recursion then used to convert to PowerFX equivalents
     */

    public class ParsedCellAnalyzer : TexlFunctionalVisitor<String, Precedence>
    {
        private ExcelParser.ParsedCell analyzedCell;
        private bool isFormula;

        public ParsedCellAnalyzer()
        {
            isFormula = false;
        }

        public ParsedCellAnalyzer(ExcelParser.ParsedCell cell)
        {
            isFormula = false;
            analyzedCell = cell;
        }

        // Parses formula passed in as a string and then converts it to PFX
        // Wraps around Analyze(TexlNode, ParsedCell)
        public static string Analyze(string formula, ExcelParser.ParsedCell cell = null)
        {
            var engine = new Engine(new PowerFxConfig());
            var parseResult = engine.Parse(formula);
            return Analyze(parseResult.Root, cell);
        }

        // Uses the Visitor design pattern to recursively convert node to PFX, outputting String of converted output
        public static string Analyze(TexlNode node, ExcelParser.ParsedCell cell = null)
        {
            var analyzer = new ParsedCellAnalyzer(cell);
            return node.Accept(analyzer, Precedence.None);
        }

        // Process UnaryOpNode, converting operator enum val to appropriate char and recursively processing operand
        public override String Visit(UnaryOpNode node, Precedence context)
        {
            // If UnaryOp is a percent sign, add it after the operand
            if (node.Op == UnaryOp.Percent)
            {
                return node.Child.Accept(this, Precedence.None) + Utils.ConvertUnaryOp(node.Op);
            }
            // Otherwise, it's a minus sign or similar and we add it beforehand
            else
            {
                return Utils.ConvertUnaryOp(node.Op) + node.Child.Accept(this, Precedence.None);
            }
        }

        public override String Visit(BoolLitNode node, Precedence context)
        {
            return node.ToString();
        }

        public override String Visit(NumLitNode node, Precedence context)
        {
            return node.ActualNumValue.ToString();
        }

        public override String Visit(FirstNameNode node, Precedence context)
        {
            // if FirstName within a func call, treat as cell reference and convert to generically named var (temporary feature)
            if (isFormula && analyzedCell != null) 
            {
                // Matches preprocessed range that is not within quotes
                Regex rx = new Regex(@"([A-Z])(\d+)_RANGE_([A-Z])(\d+)(?=([^""']*[""'][^""']*[""'])*[^""']*$)");
                Match match = rx.Match(node.Ident.Name.Value);

                if (match.Success) // if we found a preprocessed range, return unfurled range
                {
                    return Utils.ExpandRange(char.Parse(match.Groups[1].Value), int.Parse(match.Groups[2].Value), char.Parse(match.Groups[3].Value), int.Parse(match.Groups[4].Value));
                }
                else
                {
                    return Utils.GenerateGenericName(analyzedCell.SheetName, node.Ident.Name.Value);
                }
            }
            // otherwise, treat it as a new String variable creation and a cell with text in it
            else
            {
                return Utils.CreateVariable(analyzedCell.SheetName, analyzedCell.CellId, "\"" + node.Ident.Name.Value + "\"");
            }
        }

        public override String Visit(StrLitNode node, Precedence context)
        {
            // if within a func call, wrap text in quotes so it is treated as literal text and not accidentally as variable
            if (isFormula && analyzedCell != null) 
            {
                return "\"" + node.Value + "\""; 
            }
            else
            {
                return Utils.CreateVariable(analyzedCell.SheetName, analyzedCell.CellId, node);
            }
        }

        // Process BinaryOpNode, converting operator's enum val to appropriate char and recursively processing both operands
        public override String Visit(BinaryOpNode node, Precedence context)
        {
            isFormula = true;

            // recurse and return converted string for left and right operands
            // Then, add the appropriate binary op in between and return
            String opString = Utils.ConvertBinaryOp(node.Op);

            // if either of the operands is a FirstNameNode (indicating it's either a cell reference or range)
            if (node.Left.Kind == NodeKind.FirstName || node.Right.Kind == NodeKind.FirstName)
            {
                String leftStr, rightStr;
                if (node.Left.Kind == NodeKind.FirstName) 
                {
                    leftStr = ((FirstNameNode)node.Left).Ident.Name.Value;
                }
                else
                {
                    leftStr = node.Left.Accept(this, Precedence.None);
                }

                if (node.Right.Kind == NodeKind.FirstName)
                {
                    rightStr = ((FirstNameNode)node.Right).Ident.Name.Value;
                }
                else
                {
                    rightStr = node.Right.Accept(this, Precedence.None);
                }

                List<String> strList = Utils.Interpolate(leftStr, rightStr, opString);
                StringBuilder retn = new StringBuilder("");

                foreach (String str in strList)
                {
                    retn.Append(str);
                }
                return retn.ToString();
            }

            String left = node.Left.Accept(this, Precedence.None);
            String right = node.Right.Accept(this, Precedence.None);
            
            return "(" + left + " " + opString + " " + right + ")";
        }

        public override String Visit(CallNode node, Precedence context)
        {
            // Mark this as a formula so we convert cell references, etc properly
            isFormula = true;
            ListNode funcArgs = node.Args;
            var funcName = node.Head.Name;

            // First make the function name the lowercased func name to fit PFX style
            StringBuilder adjustedFuncName = new StringBuilder(Utils.AdjustFuncName(funcName.ToString())); 
            adjustedFuncName.Append("("); // then add opening parentheses for the arguments

            IReadOnlyList<TexlNode> children = funcArgs.ChildNodes;

            // Iterate through function arguments and recursively convert them to PFX style
            TexlNode arg = children[0];
            for (int i = 0; i < children.Count; i++) 
            {
                arg = children[i];

                // append represents the new portion (obtained recursively) to which to add to our return string
                String append = arg.Accept(this, Precedence.None);

                // if only one argument or this is the last arg, close the parentheses
                if (i == (children.Count - 1)) 
                {
                    adjustedFuncName.Append(append); 
                    adjustedFuncName.Append(")");
                }
                // if not the last arg, add a comma and space for the next up arg
                else if (i >= 0 && i < (children.Count - 1)) 
                {
                    adjustedFuncName.Append(append);
                    adjustedFuncName.Append(", ");
                }

            }

            return adjustedFuncName.ToString();
        }

        public override String Visit(ListNode node, Precedence context)
        {
            return node.ToString();
        }

        public override string Visit(TableNode node, Precedence context)
        {
            throw new NotImplementedException();
        }

        public override String Visit(AsNode node, Precedence context)
        {
            return node.ToString();
        }

        public override String Visit(StrInterpNode node, Precedence context)
        {
            return node.ToString();
        }

        public override String Visit(SelfNode node, Precedence context)
        {
            return node.ToString();
        }

        public override String Visit(RecordNode node, Precedence context)
        {
            return node.ToString();
        }
        public override String Visit(ParentNode node, Precedence context)
        {
            return node.ToString();
        }
        public override String Visit(ErrorNode node, Precedence context)
        {
            return node.ToString();
        }

        public override String Visit(BlankNode node, Precedence context)
        {
            return node.ToString();
        }

        public override String Visit(DottedNameNode node, Precedence context)
        {
            return node.ToString();
        }

        public override String Visit(VariadicOpNode node, Precedence context)
        {
            return node.ToString();
        }
    }
}
