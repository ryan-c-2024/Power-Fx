// <autogenerated>
// Use autogenerated to suppress stylecop warnings

using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.PowerFx;
using Microsoft.PowerFx.Core;
using Microsoft.PowerFx.Syntax;


namespace ExcelConverter
{
    /*
     * 1. ParsedCellAnalyzer can extend TexlVisitor
     * 2. ParsedCellAnalyzer.Analyze(string formula): use engine to parse nodes of formula
     * 3. Analyze(TexlNode node): "general recursion" - switch on node type, process nodes, or Accept new ParsedCellAnalyzer instance in child nodes/args
     * 4. ParsedCellAnalyzer: hold any object structures needed for that specific node, implement any specific functions
     *  e.g., Variable names <-> Identifier map, ranges as list of cells, calling pretty print, etc.
     *  
     *  Flow:
     *      - Parse Excel workbook
     *      - Pass parsed cell formulas to ParsedCellAnalyzer.Analyze(string formula)
     *      - Use PFX Engine to parse formula
     *      - Pass formula root node to Analyze(TexlNode node)
     */

    public class ParsedCellAnalyzer : TexlFunctionalVisitor<String, Precedence>
    {
        private string transformedOutput;
        private ExcelParser.ParsedCell analyzedCell;
        private bool isFunction;

        public ParsedCellAnalyzer()
        {
            transformedOutput = "";
            isFunction = false;
        }

        public ParsedCellAnalyzer(ExcelParser.ParsedCell cell)
        {
            transformedOutput = "";
            isFunction = false;
            analyzedCell = cell;
        }


        public static string Analyze(string formula, ExcelParser.ParsedCell cell = null)
        {
            var engine = new Engine(new PowerFxConfig());
            var parseResult = engine.Parse(formula);
            return Analyze(parseResult.Root, cell);
        }

        public static string Analyze(TexlNode node, ExcelParser.ParsedCell cell = null)
        {
            // ACCEPT AND VISIT ALL RETURN VOID SO DATA TO RETURNED SOME OTHER WAY
            var retVal = "";
            var analyzer = new ParsedCellAnalyzer(cell);

            if (cell != null)
            {
                retVal += cell + node.ToString();
            }
            else
            {
                retVal += node.ToString();
            }

            return retVal;

            return node.Accept(analyzer, Precedence.None);

           
            
        }

        public override String Visit(BoolLitNode node, Precedence context)
        {
            transformedOutput += node.ToString();
            return "";
        }

        public override String Visit(NumLitNode node, Precedence context)
        {
            transformedOutput += node.ToString();
            return "";
        }

        public override String Visit(FirstNameNode node, Precedence context)
        {
            if (isFunction && analyzedCell != null)
            {
                transformedOutput += Utils.GenerateGenericName(analyzedCell.SheetName, node.Ident.Name.Value);
            }
            else
            {
                transformedOutput += node.Ident.Name.Value;
            }
            return "";
        }

        public override String Visit(StrLitNode node, Precedence context)
        {
            transformedOutput += node.ToString();
            return "";
        }

        public override String Visit(BinaryOpNode node, Precedence context)
        {
            var binaryOpNode = (BinaryOpNode)node;

            String left = node.Left.Accept(this, Precedence.None);
            String right = node.Right.Accept(this, Precedence.None);

            return left + " + " + right;
        }

        public override String Visit(CallNode node, Precedence context)
        {
            isFunction = true; // mark this cell as being a function
            var retVal = Analyze(node, null);
            transformedOutput += retVal;

            var callNode = (CallNode)node;
            // process function

            var functionAnalyzer = new ParsedCellAnalyzer(cell);
            retVal += Utils.AdjustFuncName(callNode.Head.Name) + "(";

            // analyze child nodes
            foreach (var argNode in callNode.Args.ChildNodes)
            {
                String output = argNode.Accept(this, Precedence.None);
                retVal += output;
            }

            retVal = retVal.TrimEnd();
            if (retVal.EndsWith(''))
            {
                retVal = retVal.Trim(',');
            }

            retVal += ")";


            return "";


        }

        public override String Visit(ListNode node, Precedence context)
        {
            return node.ToString();
        }

        public String GetConvertedOutput() // wrapper function that returns transformed output string
        {
            return transformedOutput;
        }
    }
}
