// <autogenerated>
// Use autogenerated to suppress stylecop warnings

using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.PowerFx;
using Microsoft.PowerFx.Syntax;

namespace Excel2AppEngine
{
    /*
     * 1. ParsedCellAnalyzer can extend TexlVisitor
     * 2. ParsedCellAnalyzer.Analyze(string formula): use engine to parse nodes of formula
     * 3. Analyze(TexlNode node): "general recursion" - switch on node type, process nodes, or Accept new ParsedCellAnalyzer instance in child nodes/args
     * 4. ParsedCellAnalyzer: hold any object structures needed for that specific node, implement any specific functions
     *  e.g., Variable names <-> Identifier map, ranges as list of cells, calling pretty print, etc.
     *  
     *  Flow:
     *      - Parse Excel workbook
     *      - Pass parsed cell formulas to ParsedCellAnalyzer.Analyze(string formula)
     *      - Use PFX Engine to parse formula
     *      - Pass formula root node to Analyze(TexlNode node)
     */

    public class ParsedCellAnalyzer : TexlVisitor
    {
        private string transformedOutput;
        private ParsedCell cell;

        public ParsedCellAnalyzer()
        {
            transformedOutput = "";
            cell = null;
        }

        public static string Analyze(TexlNode node, ParsedCell c)
        {
            var analyzer = new ParsedCellAnalyzer();
            analyzer.cell = c;
            //Console.WriteLine("Current node: {0}", node.ToString());
            switch (node.Kind)
            {
                case NodeKind.NumLit:
                    // how can we do this? we need ParsedCell object to get sheet name and cell ID
                    //GenerateGenericName()
                    node.Accept(analyzer);
                    break;
                case NodeKind.BinaryOp:
                    break;
                case NodeKind.Call:
                    node.Accept(analyzer);
                    break;
                default:
                    break;
            }

            return analyzer.GetConvertedOutput(); // return converted String (have to use this function bc Analyze is static)
        }

        private static string Analyze(string formula)
        {
            var engine = new Engine(new PowerFxConfig());
            var parseResult = engine.Parse(formula);
            return Analyze(parseResult.Root);
        }

        private static string Analyze(TexlNode node)
        {
            // ACCEPT AND VISIT ALL RETURN VOID SO DATA TO RETURNED SOME OTHER WAY

            var retVal = "";
            var analyzer = new ParsedCellAnalyzer();
            Console.WriteLine("Current node: {0}", node.ToString());
            switch (node.Kind)
            {
                case NodeKind.NumLit:
                    // how can we do this? we need ParsedCell object to get sheet name and cell ID
                    //GenerateGenericName()
                    node.Accept(analyzer);
                    break;
                case NodeKind.BinaryOp:
                    break;
                case NodeKind.Call:
                    node.Accept(analyzer);
                    //Converter.ProcessFunc((CallNode)node, c);
                    break;
                default:
                    break;
            }

            return retVal;
        }

        public String GetConvertedOutput() // wrapper function that returns transformed output string
        {
            return transformedOutput;
        }

        public override bool PreVisit(CallNode node)
        {



            /*
               ListNode funcArgs = node.Args;
               var funcName = node.Head.Name;
              
                String adjustedFuncName = Converter.AdjustFuncName(funcName.ToString()) + "("; // convert func name to PowerFX style
            IReadOnlyList<TexlNode> children = funcArgs.ChildNodes;

            TexlNode arg = children[0];
            */

            transformedOutput += Converter.ProcessFunc(node, cell);

            /*
             
            for (int i = 0; i < children.Count; i++) // iterate over args and append them to output string
            {
                arg = children[i];
                String append = "";

                if (arg.Kind == NodeKind.Call) // if nested function call, we have to recurse
                {
                    append += Converter.ProcessFunc((CallNode)arg, cell);

                    // Use processfunc or arg accept?
                    //transformedOutput += arg.Accept(this);
                }
                else if (arg.Kind == NodeKind.FirstName)
                {
                    // assume its a cell
                    // change cell name to generic variable and add 
                    // append = GenerateGenericName(c.SheetName, c.CellID);
                    // SUM(1, SUM(5,B13))
                    // -> B13 to string 
                    append = Converter.GenerateGenericName(cell.SheetName, arg.ToString());
                }
                else
                {
                    append = arg.ToString();
                }

                if (i == (children.Count - 1)) // if only one argument or this is the last arg, close the parentheses
                {
                    adjustedFuncName += append + ")"; // injects arg.ToString()
                }
                else if (i >= 0 && i < (children.Count - 1)) // if not the last arg, add a comma and space for the next up arg
                {
                    adjustedFuncName += append + ", ";
                }

            }
             transformedOutput += adjustedFuncName;
            */



            //var retVal = Analyze(node);

            return false;
        }

        public override void PostVisit(StrInterpNode node)
        {
        }

        public override void PostVisit(DottedNameNode node)
        {
        }

        public override void PostVisit(UnaryOpNode node)
        {
        }

        public override void PostVisit(BinaryOpNode node)
        {
        }

        public override void PostVisit(VariadicOpNode node)
        {
        }

        public override void PostVisit(CallNode node)
        {

        }

        public override void PostVisit(ListNode node)
        {
        }

        public override void PostVisit(RecordNode node)
        {
        }

        public override void PostVisit(TableNode node)
        {
        }

        public override void PostVisit(AsNode node)
        {
        }

        public override void Visit(ErrorNode node)
        {
        }

        public override void Visit(BlankNode node)
        {
        }

        public override void Visit(BoolLitNode node)
        {
        }

        public override void Visit(StrLitNode node)
        {
        }

        public override void Visit(NumLitNode node)
        {
            transformedOutput = Converter.CreateVariable(cell.SheetName, cell.CellId, node);
        }

        public override void Visit(FirstNameNode node)
        {
        }

        public override void Visit(ParentNode node)
        {
        }

        public override void Visit(SelfNode node)
        {
        }
    }
}
